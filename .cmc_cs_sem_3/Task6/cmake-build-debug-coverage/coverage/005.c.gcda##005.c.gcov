        -:    0:Source:/home/doodox/Desktop/Contest/Sem_3/Task6/005.c
        -:    0:Graph:/home/doodox/Desktop/Contest/Sem_3/Task6/cmake-build-debug-coverage/CMakeFiles/Task6.dir/005.c.gcno
        -:    0:Data:/home/doodox/Desktop/Contest/Sem_3/Task6/cmake-build-debug-coverage/CMakeFiles/Task6.dir/005.c.gcda
        -:    0:Runs:1
        -:    1:#include <dirent.h>
        -:    2:#include <fcntl.h>
        -:    3:#include <inttypes.h>
        -:    4:#include <stdio.h>
        -:    5:#include <stdlib.h>
        -:    6:#include <string.h>
        -:    7:#include <sys/stat.h>
        -:    8:#include <unistd.h>
        -:    9:#include <errno.h>
        -:   10:
        -:   11:ssize_t
function getcwd2 called 1 returned 100% blocks executed 71%
        1:   12:getcwd2(int fd, char *buf, size_t size)
        -:   13:{
        1:   14:    if (fd == -1) {
        1:   14-block  0
переход  0 выполнен 0 (fallthrough)
переход  1 выполнен 1
    #####:   15:        return -1;
    %%%%%:   15-block  0
        -:   16:    }
        1:   17:    DIR *old_dir = opendir(".");
        1:   17-block  0
вызов    0 вернул 1
        1:   18:    if (old_dir == NULL) {
переход  0 выполнен 0 (fallthrough)
переход  1 выполнен 1
    #####:   19:        return -1;
    %%%%%:   19-block  0
        -:   20:    }
        1:   21:    if (fchdir(fd) < 0) {
        1:   21-block  0
вызов    0 вернул 1
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 1
    #####:   22:        return -1;
    %%%%%:   22-block  0
        -:   23:    }
        1:   24:    DIR *dir = fdopendir(fd);
        1:   24-block  0
вызов    0 вернул 1
        1:   25:    if (dir == NULL) {
переход  0 выполнен 0 (fallthrough)
переход  1 выполнен 1
    #####:   26:        return -1;
    %%%%%:   26-block  0
        -:   27:    }
        1:   28:    unsigned long long dirs_mem = 16;
        1:   29:    unsigned long long dirs_amount = 0;
        1:   30:    char **dirs = calloc(dirs_mem, sizeof(*dirs));
        1:   31:    if (dirs == NULL) {
        1:   31-block  0
переход  0 выполнен 0 (fallthrough)
переход  1 выполнен 1
    #####:   32:        return -1;
    %%%%%:   32-block  0
        -:   33:    }
        -:   34:    struct stat next_st;
        -:   35:    struct stat cur_st;
        -:   36:    struct stat read_st;
        -:   37:    struct dirent *cur_dir;
        -:   38:    do {
        4:   39:        DIR *next_fd = opendir("..");
        4:   39-block  0
вызов    0 вернул 4
        4:   40:        if (next_fd == NULL) {
переход  0 выполнен 0 (fallthrough)
переход  1 выполнен 4
    #####:   41:            return -1;
    %%%%%:   41-block  0
        -:   42:        }
        4:   43:        DIR *cur_fd = opendir(".");
        4:   43-block  0
вызов    0 вернул 4
        4:   44:        if (cur_fd == NULL) {
переход  0 выполнен 0 (fallthrough)
переход  1 выполнен 4
    #####:   45:            return -1;
    %%%%%:   45-block  0
        -:   46:        }
        4:   47:        if (fstat(dirfd(next_fd), &next_st) < 0) {
        4:   47-block  0
вызов    0 вернул 4
вызов    1 вернул 4
переход  2 выполнен 0 (fallthrough)
переход  3 выполнен 4
    #####:   48:            return -1;
    %%%%%:   48-block  0
        -:   49:        }
        4:   50:        if (fstat(dirfd(cur_fd), &cur_st) < 0) {
        4:   50-block  0
вызов    0 вернул 4
вызов    1 вернул 4
переход  2 выполнен 0 (fallthrough)
переход  3 выполнен 4
    #####:   51:            return -1;
    %%%%%:   51-block  0
        -:   52:        }
        4:   53:        if (next_st.st_ino == cur_st.st_ino && next_st.st_dev == cur_st.st_dev) {
        4:   53-block  0
переход  0 выполнен 2 (fallthrough)
переход  1 выполнен 2
        2:   53-block  1
переход  2 выполнен 1 (fallthrough)
переход  3 выполнен 1
        1:   54:            closedir(next_fd);
        1:   54-block  0
вызов    0 вернул 1
        1:   55:            closedir(cur_fd);
вызов    0 вернул 1
        1:   56:            break;
        -:   57:        }
        3:   58:        if (dirfd(dir) != fd) {
        3:   58-block  0
вызов    0 вернул 3
переход  1 выполнен 1 (fallthrough)
переход  2 выполнен 2
        1:   59:            close(dirfd(dir));
        1:   59-block  0
вызов    0 вернул 1
вызов    1 вернул 1
        -:   60:        }
        3:   61:        closedir(dir);
        3:   61-block  0
вызов    0 вернул 3
        3:   62:        dir = fdopendir(dirfd(next_fd));
вызов    0 вернул 3
вызов    1 вернул 3
        -:   63:        //closedir(next_fd);
        3:   64:        closedir(cur_fd);
вызов    0 вернул 3
        3:   65:        if (dir == NULL) {
переход  0 выполнен 0 (fallthrough)
переход  1 выполнен 3
    #####:   66:            return -1;
    %%%%%:   66-block  0
        -:   67:        }
        3:   68:        if (fchdir(dirfd(next_fd)) < 0) {
        3:   68-block  0
вызов    0 вернул 3
вызов    1 вернул 3
переход  2 выполнен 0 (fallthrough)
переход  3 выполнен 3
    #####:   69:            return -1;
    %%%%%:   69-block  0
        -:   70:        }
        -:   71:        do {
       43:   72:            if ((cur_dir = readdir(dir)) == NULL) {
       43:   72-block  0
вызов    0 вернул 43
переход  1 выполнен 0 (fallthrough)
переход  2 выполнен 43
    #####:   73:                return -1;
    %%%%%:   73-block  0
        -:   74:            }
       43:   75:            DIR *read_fd = opendir(cur_dir->d_name);
       43:   75-block  0
вызов    0 вернул 43
       43:   76:            if (read_fd == NULL) {
переход  0 выполнен 15 (fallthrough)
переход  1 выполнен 28
       15:   77:                read_st.st_ino = ~cur_st.st_ino;
       15:   78:                continue;
       15:   78-block  0
        -:   79:            }
       28:   80:            if (fstat(dirfd(read_fd), &read_st) < 0) {
       28:   80-block  0
вызов    0 вернул 28
вызов    1 вернул 28
переход  2 выполнен 0 (fallthrough)
переход  3 выполнен 28
    #####:   81:                return -1;
    %%%%%:   81-block  0
        -:   82:            }
       28:   83:            closedir(read_fd);
       28:   83-block  0
вызов    0 вернул 28
       43:   84:        } while (read_st.st_ino != cur_st.st_ino || read_st.st_dev != cur_st.st_dev);
       43:   84-block  0
переход  0 выполнен 38
переход  1 выполнен 5 (fallthrough)
        5:   84-block  1
переход  2 выполнен 2
переход  3 выполнен 3 (fallthrough)
        3:   85:        if (dirs_amount >= dirs_mem) {
        3:   85-block  0
переход  0 выполнен 0 (fallthrough)
переход  1 выполнен 3
    #####:   86:            dirs_mem += dirs_mem;
    #####:   87:            dirs = realloc(dirs, dirs_mem * sizeof(*dirs));
    #####:   88:            if (dirs == NULL) {
    %%%%%:   88-block  0
переход  0 ни разу не выполнялся
переход  1 ни разу не выполнялся
    #####:   89:                return -1;
    %%%%%:   89-block  0
        -:   90:            }
        -:   91:        }
        3:   92:        dirs[dirs_amount++] = strdup(cur_dir->d_name);
        3:   93:    } while(next_st.st_ino != cur_st.st_ino || next_st.st_dev != cur_st.st_dev);
        3:   93-block  0
переход  0 выполнен 2
переход  1 выполнен 1 (fallthrough)
        1:   93-block  1
переход  2 выполнен 1
переход  3 выполнен 0 (fallthrough)
        1:   94:    closedir(dir);
        1:   94-block  0
вызов    0 вернул 1
        1:   95:    if (dirs_amount == 0) {
переход  0 выполнен 0 (fallthrough)
переход  1 выполнен 1
    #####:   96:        if (size > 0 && buf != NULL) {
    %%%%%:   96-block  0
переход  0 ни разу не выполнялся
переход  1 ни разу не выполнялся
    %%%%%:   96-block  1
переход  2 ни разу не выполнялся
переход  3 ни разу не выполнялся
    #####:   97:            strncpy(buf, "/", size - 1);
    %%%%%:   97-block  0
        -:   98:        }
    #####:   99:        if (fchdir(dirfd(old_dir)) < 0) {
    %%%%%:   99-block  0
вызов   0 ни разу не исполнялся
вызов   1 ни разу не исполнялся
переход  2 ни разу не выполнялся
переход  3 ни разу не выполнялся
    #####:  100:            return -1;
    %%%%%:  100-block  0
        -:  101:        }
    #####:  102:        closedir(old_dir);
    %%%%%:  102-block  0
вызов   0 ни разу не исполнялся
    #####:  103:        free(dirs);
    #####:  104:        return 1;
        -:  105:    }
        1:  106:    char *new_buf = calloc(PATH_MAX + 1, sizeof(*new_buf));
        1:  107:    if (new_buf == NULL) {
        1:  107-block  0
переход  0 выполнен 0 (fallthrough)
переход  1 выполнен 1
    #####:  108:        return -1;
    %%%%%:  108-block  0
        -:  109:    }
        1:  110:    int new_size = 0;
        4:  111:    while (dirs_amount > 0) {
        1:  111-block  0
        4:  111-block  1
переход  0 выполнен 3
переход  1 выполнен 1 (fallthrough)
        3:  112:        int old_size = new_size;
        3:  113:        new_size += snprintf(new_buf + new_size, PATH_MAX - new_size, "/%s", dirs[--dirs_amount]);
        3:  114:        free(dirs[dirs_amount]);
        3:  115:        if (old_size > new_size) {
        3:  115-block  0
переход  0 выполнен 0 (fallthrough)
переход  1 выполнен 3
    #####:  116:            return -1;
    %%%%%:  116-block  0
        -:  117:        }
        -:  118:    }
        1:  119:    free(dirs);
        1:  120:    if (size > 0 && buf != NULL) {
        1:  120-block  0
переход  0 выполнен 1 (fallthrough)
переход  1 выполнен 0
        1:  120-block  1
переход  2 выполнен 1 (fallthrough)
переход  3 выполнен 0
        1:  121:        strncpy(buf, new_buf, size - 1);
        1:  121-block  0
        -:  122:    }
        1:  123:    if (fchdir(dirfd(old_dir)) < 0) {
        1:  123-block  0
вызов    0 вернул 1
вызов    1 вернул 1
переход  2 выполнен 0 (fallthrough)
переход  3 выполнен 1
    #####:  124:        return -1;
    %%%%%:  124-block  0
        -:  125:    }
        1:  126:    closedir(old_dir);
        1:  126-block  0
вызов    0 вернул 1
        1:  127:    free(new_buf);
        1:  128:    return new_size;
        -:  129:}
        -:  130:
        -:  131:int
function main called 1 returned 100% blocks executed 100%
        1:  132:main(int argc, const char *argv[])
        -:  133:{
        1:  134:    DIR *file = opendir(argv[1]);
        1:  134-block  0
вызов    0 вернул 1
        1:  135:    long n = strtol(argv[2], NULL, 10);
вызов    0 вернул 1
        1:  136:    char *buf = calloc(n, sizeof(*buf));
        1:  137:    char *path = calloc(151, sizeof(*path));
        1:  138:    getcwd(path, 150);
вызов    0 вернул 1
        1:  139:    puts(path);
вызов    0 вернул 1
        1:  140:    int a = getcwd2(dirfd(file), buf, n);
вызов    0 вернул 1
вызов    1 вернул 1
        1:  141:    if(buf!=0)puts(buf);
переход  0 выполнен 1 (fallthrough)
переход  1 выполнен 0
        1:  141-block  0
вызов    2 вернул 1
        1:  142:    printf("%d\n", a);
        1:  142-block  0
вызов    0 вернул 1
        1:  143:    getcwd(path, 150);
вызов    0 вернул 1
        1:  144:    puts(path);
вызов    0 вернул 1
        1:  145:    printf("%d\n", dirfd(file));
вызов    0 вернул 1
вызов    1 вернул 1
        1:  146:    free(buf);
        1:  147:    free(path);
        1:  148:    closedir(file);
вызов    0 вернул 1
        1:  149:    return 0;
        -:  150:}
